/*=============================================================================*
 * M5Stadk_RemoteKeyerWifi ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”¨ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢  Ver1.03
 * M5Stack ATOM S3 Lite å¯¾å¿œ ATOM Liteã¨å…±ç”¨ã‚½ãƒ¼ã‚¹åŒ–
 * Wifiãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚½ãƒ¼ã‚¹åˆ†é›¢/SDã‚«ãƒ¼ãƒ‰ã‹ã‚‰å–ã‚Šè¾¼ã¿ã€EEPROMã¸æ›¸ãè¾¼ã¿/èª­ã¿å‡ºã—
 * Wifiãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠå¯¾å¿œ
 * DHCPå¯¾å¿œ
 * ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆé€šä¿¡å¯¾å¿œ
 * ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆé€šä¿¡ã®å®‰å®šæ€§å‘ä¸Š
 * Copyright (C) 2025- JI1ORE
 *=============================================================================*/
#include <WiFi.h>
#include <WiFiUdp.h>
#include <ESPmDNS.h>
#include <Adafruit_NeoPixel.h>
#include "esp_wifi.h"
#include <EEPROM.h>
#include <SD.h>
#include "M5Unified.h"
#define EEPROM_ADDR_PROFILE_INDEX 0
#define EEPROM_ADDR_PROFILE_BASE 16
#define MAX_WIFI_PROFILES 5
#define EEPROM_SIZE (sizeof(WiFiProfileEEPROM) * MAX_WIFI_PROFILES + 16)

#define MAX_SSID_LEN 32
#define MAX_PASS_LEN 64
#define MAX_HOSTNAME_LEN 32
#define PROFILE_MAGIC 0xA5

struct __attribute__((packed)) WiFiProfileEEPROM
{
  uint8_t magic; // ãƒ‡ãƒ¼ã‚¿æœ‰åŠ¹ãƒ•ãƒ©ã‚°
  char ssid[MAX_SSID_LEN];
  char password[MAX_PASS_LEN];
  uint8_t localIP[4];
  uint8_t gateway[4];
  uint8_t subnet[4];
  uint8_t serverIP[4];
  bool isApMode;
  bool hasIP;
  uint8_t colorId;
  char hostname[MAX_HOSTNAME_LEN];
  char serverhostname[MAX_HOSTNAME_LEN];
};

// ==== ãƒ”ãƒ³å®šç¾© ====
#ifdef M5ATOMLite
const int KEY_PIN = 19;
const int LED_PIN = 27;
const int BUTTON_PIN = 39;
const int SD_SPI_CS_PIN = 22;
const int SD_SPI_SCK_PIN = 23;
const int SD_SPI_MISO_PIN = 33;
const int SD_SPI_MOSI_PIN = 19;
#elif M5ATOMS3Lite
const int KEY_PIN = 6;
const int LED_PIN = 35;
const int BUTTON_PIN = 41;
const int SD_SPI_CS_PIN = -1;
const int SD_SPI_SCK_PIN = 7;
const int SD_SPI_MISO_PIN = 8;
const int SD_SPI_MOSI_PIN = 6;
#endif
#define NUMPIXELS 1
#define ESP_INTR_FLAG_DEFAULT 0
#define SD_Filename "/wifi_client_profile.txt"

// ==== è‰²è¨­å®š ====
struct ColorProfile
{
  const char *name;
  uint8_t r;
  uint8_t g;
  uint8_t b;
};

ColorProfile MagentaProfile = {"Magenta", 255, 0, 255};
ColorProfile yellowProfile = {"Yellow", 255, 255, 0};
ColorProfile cyanProfile = {"Cyan", 0, 255, 255};
ColorProfile RedProfile = {"Red", 255, 0, 0};
ColorProfile BlueProfile = {"Blue", 0, 0, 255};
ColorProfile GreenProfile = {"Green", 0, 255, 0};
ColorProfile WhiteProfile = {"White", 255, 255, 255};

// ==== WiFiè¨­å®š ====
struct WiFiProfile
{
  const char *ssid;
  const char *password;
  IPAddress localIP;
  IPAddress gateway;
  IPAddress subnet;
  IPAddress serverIP;
  bool isApMode; // APæ¥ç¶šã‹ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆæ¥ç¶šã‹
  bool hasIP;    // IPç›´æŒ‡å®šã‹DHCPã‹
  ColorProfile *color;
  const char *hostname;
  const char *serverhostname;
};

WiFiProfile wifiProfiles[MAX_WIFI_PROFILES];
int profileCount = 0;
#ifdef LoadFromSource
WiFiProfile defaultProfiles[] = {
    {"UENO-a", "hogehoge33", IPAddress(192, 168, 1, 51), IPAddress(192, 168, 1, 1), IPAddress(255, 255, 255, 0), IPAddress(192, 168, 1, 50), false, false, &cyanProfile, "RKCLIENT01", "RKSERVER01"},
    {"Ueno-mini1", "hogehoge33", IPAddress(172, 20, 10, 6), IPAddress(172, 20, 10, 1), IPAddress(255, 255, 255, 240), IPAddress(172, 20, 10, 5), false, false, &MagentaProfile, "RKCLIENT01", "RKSERVER01"},
    {"RemoteKeyer-AP", "password123", IPAddress(192, 168, 4, 2), IPAddress(192, 168, 4, 1), IPAddress(255, 255, 255, 0), IPAddress(192, 168, 4, 1), true, false, &yellowProfile, "RKCLIENT01", "RKSERVER01"}};
#endif

IPAddress serverIP;

// ==== UDPè¨­å®š ====
#define LOCAL_PORT 8888
#define SERVER_PORT 8888
WiFiUDP Udp;

Adafruit_NeoPixel pixels(NUMPIXELS, LED_PIN, NEO_GRB + NEO_KHZ800);

// ==== å‹•ä½œãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ====
unsigned long MAX_ON_DURATION = 3000;
const int PING_INTERVAL = 5000;
const int ReCal_RTT = 5000;
int keyRepeatCount = 5;                // å³æ™‚å¤‰åŒ–ãƒ‘ã‚±ãƒƒãƒˆã®é‡è¤‡é€ä»˜å›æ•°
const int SAMPLE_SEND_DUP_CNT = 1;      // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ‘ã‚±ãƒƒãƒˆã®é‡è¤‡é€ä»˜å›æ•°
const int SAMPLE_INTERVAL_MS = 10;      // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã®å‘¨æœŸ(msec)
const int SAMPLE_SEND_AMNT = 8;         // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ‘ã‚±ãƒƒãƒˆã®é€ä»˜ã‚µã‚¤ã‚º(å¤‰æ›´æ™‚ã¯é€ä»˜ãƒ‘ã‚±ãƒƒãƒˆã®ä¿®æ­£ãŒå¿…è¦)
const int SAMPLE_SUPPRESS_MS = 10;      // å³æ™‚é€ä¿¡å¾Œã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚’æŠ‘åˆ¶ã™ã‚‹æ™‚é–“
const unsigned long DEBOUNCE_US = 5000; // å‰²ã‚Šè¾¼ã¿å‡¦ç†
volatile unsigned long lastKeyChangeMicros = 0;
const int HOSTNAME_RESTIME = 30; // åå‰è§£æ±ºã®å¾…æ©Ÿæ™‚é–“

// ==== é…å»¶åˆ†é¡ ====
// pingè¿”é€æ™‚é–“(msec)
const int RTT_THRESH_1 = 5;
const int RTT_THRESH_2 = 10;
const int RTT_THRESH_3 = 25;
const int RTT_THRESH_4 = 50;
const int RTT_THRESH_5 = 75;
const int RTT_THRESH_6 = 100;
const int RTT_THRESH_7 = 200;

// pingè¿”é€æ™‚é–“é–“éš”ã”ã¨ã®é…å»¶æ™‚é–“å®šç¾©(msec)
const int DELAY_VERY_LOW = 50;   // RTT_THRESH_1ä»¥ä¸‹
const int DELAY_LOW = 50;        // RTT_THRESH_2ä»¥ä¸‹
const int DELAY_MID = 50;        // RTT_THRESH_3ä»¥ä¸‹
const int DELAY_HIGH = 50;       // RTT_THRESH_4ä»¥ä¸‹
const int DELAY_VERY_HIGH = 100;  // RTT_THRESH_5ä»¥ä¸‹
const int DELAY_VERY2_HIGH = 150; // RTT_THRESH_6ä»¥ä¸‹
const int DELAY_VERY3_HIGH = 200; // RTT_THRESH_7ä»¥ä¸‹
const int DELAY_MAX = 500;        // RTT_THRESH_7è¶…


const unsigned long BLINK_INTERVAL_WIFI = 1000;
const unsigned long BLINK_INTERVAL_SYNC = 300;
unsigned long blinkInterval = BLINK_INTERVAL_WIFI;
unsigned long lastSyncRequestMillis = 0;

// ==== çŠ¶æ…‹ç®¡ç† ====
volatile bool immediateSendRequested = false;
volatile bool keyState = false;
volatile unsigned long lastIsrMicros = 0;

// unsigned long lastSendMicros = 0;
unsigned long lastOnMillis = 0;
unsigned long lastBlinkMillis = 0;
unsigned long lastPingMillis = 0;
unsigned long lastPingSendMillis = 0;
long delayOffsetMs = 0;
bool timeSynced = false;
bool ledState = false;
unsigned long dynamicTimeout = 8000;
static unsigned long lastDelayRecalcMillis = 0;
int fixedDelayMs = 50;
bool fixedDelayLocked = false;
bool wifiWasDisconnected = false;
bool currentKeyState = false;

int lostPingCount = 0;
bool pongReceived = true; // pongå¿œç­”ãŒæ¥ãŸã‹ã©ã†ã‹

const unsigned long DEFAULT_TIMEOUT = 12000;
int activeProfileIndex = -1;
unsigned long profileSelectStart = 0;
const unsigned long PROFILE_SELECT_WINDOW = 10000; // 10ç§’
int selectedProfileIndex = 0;
unsigned long fixedDelayLockUntil = 0;

// ==== ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ç”¨å¤‰æ•° ====
static byte keyBuf = 0;
static int sampleIndex = 0;
static unsigned long sampleStartTimeMs = 0;
static unsigned long lastSampleTimeMs = 0;
const int PACKET_SEND_INTERVAL_MS = SAMPLE_INTERVAL_MS * SAMPLE_SEND_AMNT;
unsigned long lastImmediateSendMillis = 0;
unsigned long sampleTimes[8];

// ==== é–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ— ====
bool connectToWiFi();
void requestMillisSync();
void sendKeyPacket(bool isOn, byte trxSel, uint64_t opTimeMs);
void initLed();
void clearLed();
void setLedFromProfileIndex(int index);
void setLedColor(uint8_t r, uint8_t g, uint8_t b);
void setLedColorFromProfile(ColorProfile *color);
void flashLedProfile(ColorProfile *color, int durationMs, int repeat);
void flashOnce(ColorProfile *color, int durationMs);
void flashRedBeforeRestart();
void saveProfileIndexToEEPROM(int index);
int loadProfileIndexFromEEPROM();
bool loadWiFiProfilesFromSD();
void saveWiFiProfileToEEPROM(const WiFiProfile &src, int index);
bool loadWiFiProfileFromEEPROM(WiFiProfile &dst, int index);
void clearEEPROM();
bool restoreProfilesFromEEPROM();
void getserverIP();

// ==== RTTå±¥æ­´ ====
const int RTT_HISTORY_SIZE = 5;
long rttHistory[RTT_HISTORY_SIZE] = {0};
int rttIndex = 0;
long pingRttMs = 0;

// ==== æ™‚é–“åŒæœŸç”¨ ====
const int SYNC_SAMPLE_COUNT = 10;
int syncSampleIndex = 0;
long syncOffsets[SYNC_SAMPLE_COUNT];
bool syncCollecting = false;

long getAverageRtt()
{
  long sum = 0;
  for (int i = 0; i < RTT_HISTORY_SIZE; i++)
    sum += rttHistory[i];
  return sum / RTT_HISTORY_SIZE;
}

void keyISR(void *arg)
{
  if (!timeSynced)
    return;
  unsigned long now = micros();
  if (now - lastIsrMicros < DEBOUNCE_US)
    return;
  lastIsrMicros = now;
  keyState = (digitalRead(KEY_PIN) == LOW);
  lastKeyChangeMicros = now; // â† è¿½åŠ 
  immediateSendRequested = true;
}
// ==== åˆæœŸåŒ– ====
void setup()
{
  //  Serial.begin(115200);
  EEPROM.begin(EEPROM_SIZE);
#ifdef LoadFromSource
  profileCount = sizeof(defaultProfiles) / sizeof(WiFiProfile);
  for (int i = 0; i < profileCount && i < MAX_WIFI_PROFILES; i++)
  {
    wifiProfiles[i] = defaultProfiles[i];
  }
#endif
  auto cfg = M5.config();
  cfg.external_spk = false; // å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ç„¡åŠ¹
  cfg.internal_mic = false; // å†…è”µãƒã‚¤ã‚¯ç„¡åŠ¹
  cfg.output_power = false; // é›»æºåˆ¶å¾¡ãƒ”ãƒ³ç„¡åŠ¹
  cfg.clear_display = true; // ç”»é¢åˆæœŸåŒ–ã‚ã‚Šï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
  M5.begin(cfg);
#ifdef LoadFromSource
#else
  bool sdAvailable = false;
  delay(500);
  SPI.begin(SD_SPI_SCK_PIN, SD_SPI_MISO_PIN, SD_SPI_MOSI_PIN, SD_SPI_CS_PIN);

  if (SD.begin(SD_SPI_CS_PIN) && SD.exists(SD_Filename))
  {
    // Serial.println("SDã‚«ãƒ¼ãƒ‰åˆæœŸåŒ–æˆåŠŸï¼");
    if (loadWiFiProfilesFromSD())
    {
      clearEEPROM();
      for (int i = 0; i < profileCount; i++)
      {
        saveWiFiProfileToEEPROM(wifiProfiles[i], i);
      }
      saveProfileIndexToEEPROM(0);
      delay(100);

      // âœ… æˆåŠŸé€šçŸ¥ï¼šé’ãƒ©ãƒ³ãƒ—ç‚¹ç¯
      initLed();
      flashLedProfile(&BlueProfile, 2000, 1);

      while (true)
        delay(100);
    }
    else
    {
      // âŒï¸ å¤±æ•—é€šçŸ¥ï¼šèµ¤ãƒ©ãƒ³ãƒ—ç‚¹ç¯
      initLed();
      flashLedProfile(&RedProfile, 2000, 1);

      while (true)
        delay(100);
    }
  }
  else
  {
    // Serial.println("SDã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚EEPROMã‹ã‚‰å¾©å…ƒã—ã¾ã™ã€‚");
  }

  // âœ… EEPROMã‹ã‚‰ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒ
  if (!restoreProfilesFromEEPROM())
  {
    initLed();
    while (true)
    {
      flashOnce(&RedProfile, BLINK_INTERVAL_SYNC);
      delay(BLINK_INTERVAL_SYNC);
    }
  }

  if (selectedProfileIndex >= profileCount)
  {
    // Serial.println("âš ï¸ EEPROMã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç„¡åŠ¹ã§ã™ã€‚0ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™");
    selectedProfileIndex = 0;
  }

#endif

  selectedProfileIndex = loadProfileIndexFromEEPROM();
  activeProfileIndex = selectedProfileIndex;

  if (profileCount == 0)
  {
    // Serial.println("EEPROMã«æœ‰åŠ¹ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
    //  ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„ã®ã§ã€colorã‚‚è¨­å®šã—ãªã„
    return;
  }

  if (selectedProfileIndex >= profileCount)
  {
    // Serial.println("âš ï¸ EEPROMã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç„¡åŠ¹ã§ã™ã€‚0ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™");
    selectedProfileIndex = 0;
  }

  activeProfileIndex = selectedProfileIndex;

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(KEY_PIN, INPUT_PULLUP);

  profileSelectStart = millis();

  initLed();

  ColorProfile *c = wifiProfiles[selectedProfileIndex].color;
  if (!c)
  {
    // Serial.println("âš ï¸ color ãŒ null ã§ã™ï¼");
    c = &RedProfile; // å®‰å…¨ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«é€€é¿
    wifiProfiles[selectedProfileIndex].color = c;
  }
  setLedFromProfileIndex(selectedProfileIndex);

  // 10ç§’é–“ã ã‘é¸æŠå¯èƒ½
  while (millis() - profileSelectStart < PROFILE_SELECT_WINDOW)
  {
    static bool lastButtonState = HIGH;
    bool buttonState = digitalRead(BUTTON_PIN);
    if (lastButtonState == HIGH && buttonState == LOW)
    {
      selectedProfileIndex = (selectedProfileIndex + 1) % profileCount;
      setLedFromProfileIndex(selectedProfileIndex);
      // Serial.printf("ğŸ”„ ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«åˆ‡æ›¿: %d (%s)\n", selectedProfileIndex, wifiProfiles[selectedProfileIndex].ssid);
    }
    lastButtonState = buttonState;
    delay(100);
  }

  setLedFromProfileIndex(selectedProfileIndex);

  saveProfileIndexToEEPROM(selectedProfileIndex);
  EEPROM.end();

  activeProfileIndex = selectedProfileIndex;
  gpio_pad_select_gpio((gpio_num_t)BUTTON_PIN);
  gpio_set_direction((gpio_num_t)BUTTON_PIN, GPIO_MODE_DISABLE);
  gpio_install_isr_service(ESP_INTR_FLAG_DEFAULT);
  gpio_set_intr_type((gpio_num_t)KEY_PIN, GPIO_INTR_ANYEDGE);
  gpio_isr_handler_add((gpio_num_t)KEY_PIN, keyISR, NULL);
  // attachInterrupt(digitalPinToInterrupt(KEY_PIN), keyISR, CHANGE);
  connectToWiFi();
  getserverIP();
  Udp.begin(LOCAL_PORT);
  requestMillisSync();
  lastPingMillis = millis();
}

// ==== LEDåˆ¶å¾¡ç”¨é–¢æ•° ====
void setLedColor(uint8_t r, uint8_t g, uint8_t b)
{
  pixels.setPixelColor(0, pixels.Color(r, g, b));
  pixels.show();
}

// ==== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ====
void loop()
{
  unsigned long nowMicros = micros();
  unsigned long nowMillis = millis();
  byte trxCode = 0x01; // å›ºå®šã™ã‚‹

  // ==== SYNCå†é€ã®å¼·åŒ–ï¼ˆåˆå›ï¼‹å‘¨æœŸï¼‰ ====

  static bool syncRequested = false;
  static unsigned long lastSyncRetryMillis = 0;

  if (!timeSynced && WiFi.status() == WL_CONNECTED)
  {
    if (!syncRequested || millis() - lastSyncRetryMillis >= 5000)
    {
      requestMillisSync();
      syncRequested = true;
      syncCollecting = true;
      syncSampleIndex = 0;
      lastSyncRetryMillis = millis();
      // Serial.println("SYNCè¦æ±‚ã‚’é€ä¿¡ã—ã¾ã—ãŸ");
    }
  }

  // å³æ™‚é€ä¿¡å‡¦ç†
  bool doSend = false;
  bool sendState = false;
  noInterrupts();
  if (immediateSendRequested)
  {
    doSend = true;
    sendState = keyState;
    unsigned long isrMicros = lastKeyChangeMicros; // â† å‰²ã‚Šè¾¼ã¿æ™‚åˆ»ã‚’å–å¾—
    // delay(2);
    immediateSendRequested = false;
  }
  interrupts();

  if (doSend && timeSynced)
  {
    fixedDelayLocked = true; // â‘  é…å»¶æ™‚é–“ã®å†è©•ä¾¡ã‚’é˜²æ­¢

    currentKeyState = sendState;
    uint64_t opTimeMs = (lastKeyChangeMicros / 1000) + delayOffsetMs + fixedDelayMs;
    int repeat = currentKeyState ? 1 : 3; // OFFæ™‚ã¯3å›é€ä¿¡
    for (int i = 0; i < repeat; i++)
    {
      sendKeyPacket(currentKeyState, trxCode, opTimeMs); // opTimeMsã¯å›ºå®š
#ifdef M5ATOMLite
      yield();
#elif M5ATOMS3Lite
      // delay(1);
      taskYIELD();
#endif
    }

    // lastSendMicros = nowMicros;
    lastOnMillis = currentKeyState ? nowMillis : lastOnMillis;
    lastImmediateSendMillis = millis();
  }

  // ==== SAMPLE_INTERVAL_MSã”ã¨ã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å‡¦ç† ====
  if (timeSynced && millis() - lastSampleTimeMs >= SAMPLE_INTERVAL_MS)
  {
    // å³æ™‚é€ä¿¡å¾Œã¯æŠ‘åˆ¶
    if (millis() - lastImmediateSendMillis < SAMPLE_SUPPRESS_MS)
      return;
    // å³æ™‚é€ä¿¡ä¸­ã¯ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é€ä¿¡ã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (immediateSendRequested)
      return;

    lastSampleTimeMs = millis();
    bool down = (digitalRead(KEY_PIN) == LOW);
    if (sampleIndex == 0)
    {
      sampleStartTimeMs = millis();
      keyBuf = 0; // â† åˆæœŸåŒ–ã‚’ã“ã“ã«ç§»å‹•
    }

    sampleTimes[sampleIndex] = millis(); // â† ã“ã“ã«è¿½åŠ ï¼

    if (down)
      keyBuf |= (1 << sampleIndex);
    sampleIndex++;

    if (sampleIndex >= SAMPLE_SEND_AMNT)
    {
      // byte trxCode = (digitalRead(TRX_PIN) == LOW) ? 0x02 : 0x01;
      trxCode = 0x01;
      byte pkt[13];
      pkt[0] = trxCode;
      pkt[1] = keyBuf;
      pkt[2] = (sampleStartTimeMs >> 16) & 0xFF;
      pkt[3] = (sampleStartTimeMs >> 8) & 0xFF;
      pkt[4] = sampleStartTimeMs & 0xFF;
      for (int i = 0; i < 8; i++)
      {
        byte delta = (byte)constrain(sampleTimes[i] - sampleStartTimeMs, 0, 255);
        pkt[5 + i] = delta;
      }

      for (int i = 0; i < SAMPLE_SEND_DUP_CNT; i++)
      {
        Udp.beginPacket(serverIP, SERVER_PORT);
        Udp.write(pkt, 13);
        Udp.endPacket();
#ifdef M5ATOMLite
        yield();
#elif M5ATOMS3Lite
        // delay(1);
        taskYIELD();
#endif
      }

      sampleIndex = 0;
    }
  }

  // UDPå—ä¿¡å‡¦ç†
  if (WiFi.status() == WL_CONNECTED)
  {
    int size = Udp.parsePacket();
    if (size > 0)
    {
      byte buf[12];
      int len = Udp.read(buf, size);

      if (size == 9 && buf[0] == 0xE1)
      {
        uint64_t serverRecvMs = 0;
        for (int i = 0; i < 8; i++)
          serverRecvMs = (serverRecvMs << 8) | buf[1 + i];

        long offset = (long)serverRecvMs - (long)nowMillis;

        // Serial.printf("ğŸ•’ SYNCå¿œç­”: serverRecvMs=%llu, nowMillis=%lu, delayOffsetMs=%ld\n", serverRecvMs, nowMillis, offset);

        // === ã‚µãƒ¼ãƒãƒ¼å†èµ·å‹•æ¤œå‡º ===
        if (offset < 3000)
        {
          flashRedBeforeRestart();
          ESP.restart();
          return;
        }

        // === è¤‡æ•°å›SYNCåé›†ä¸­ãªã‚‰è¨˜éŒ² ===
        if (syncCollecting)
        {
          if (syncSampleIndex < SYNC_SAMPLE_COUNT)
          {
            syncOffsets[syncSampleIndex++] = offset;
          }

          if (syncSampleIndex >= SYNC_SAMPLE_COUNT)
          {
            // æœ€å°å€¤ã‚’é¸ã¶
            long minOffset = syncOffsets[0];
            for (int i = 1; i < SYNC_SAMPLE_COUNT; i++)
            {
              if (syncOffsets[i] < minOffset)
                minOffset = syncOffsets[i];
            }

            delayOffsetMs = minOffset;
            timeSynced = true;
            syncCollecting = false;

            // Serial.printf("âœ… SYNCå®Œäº†: æœ€å° delayOffsetMs=%ld\n", delayOffsetMs);

            // ä»¥ä¸‹ã€åˆæœŸåŒ–å‡¦ç†ï¼ˆå¿…è¦ãªã‚‰ã“ã“ã« fixedDelayMs è¨­å®šãªã©ã‚‚ï¼‰
            fixedDelayLocked = true;
            fixedDelayLockUntil = millis() + 30000;
            blinkInterval = BLINK_INTERVAL_SYNC;
            rttIndex = 0;
            for (int i = 0; i < RTT_HISTORY_SIZE; i++)
              rttHistory[i] = 0;
            sampleIndex = 0;
            keyBuf = 0;
            lastSampleTimeMs = millis();
            lastSyncRequestMillis = millis();
            lastSyncRetryMillis = millis();

            setLedColorFromProfile(&RedProfile);
            delay(100);
            currentKeyState ? setLedColorFromProfile(&GreenProfile) : clearLed();
          }
          else
          {
            requestMillisSync();
            lastSyncRetryMillis = millis();
          }

          return; // ã¾ã åé›†ä¸­ãªã®ã§ã“ã“ã§çµ‚äº†
        }

        delayOffsetMs = offset;

        // ä»¥ä¸‹ã€é€šå¸¸ã®SYNCå‡¦ç†ï¼ˆåˆæœŸåŒ–ãªã©ï¼‰
        timeSynced = true;
        // RTTã«å¿œã˜ã¦åˆæœŸé…å»¶ã‚’è¨­å®šï¼ˆå›ºå®šåŒ–ï¼‰
        if (pingRttMs <= RTT_THRESH_1)
          fixedDelayMs = DELAY_VERY_LOW;
        else if (pingRttMs <= RTT_THRESH_2)
          fixedDelayMs = DELAY_LOW;
        else if (pingRttMs <= RTT_THRESH_3)
          fixedDelayMs = DELAY_MID;
        else if (pingRttMs <= RTT_THRESH_4)
          fixedDelayMs = DELAY_HIGH;
        else if (pingRttMs <= RTT_THRESH_5)
          fixedDelayMs = DELAY_VERY_HIGH;
        else if (pingRttMs <= RTT_THRESH_6)
          fixedDelayMs = DELAY_VERY2_HIGH;
        else if (pingRttMs <= RTT_THRESH_7)
          fixedDelayMs = DELAY_VERY3_HIGH;
        else
          fixedDelayMs = DELAY_MAX;

        fixedDelayLocked = true;                // é€šå¸¸ã¯ãƒ­ãƒƒã‚¯ã—ã¦å®‰å®šé‹ç”¨
        fixedDelayLockUntil = millis() + 30000; // 10ç§’é–“ãƒ­ãƒƒã‚¯ç¶­æŒ

        lastPingMillis = nowMillis;
        lastPingSendMillis = nowMillis;
        blinkInterval = BLINK_INTERVAL_SYNC;

        // fixedDelayLocked = false;
        rttIndex = 0;
        for (int i = 0; i < RTT_HISTORY_SIZE; i++)
          rttHistory[i] = 0;

        sampleIndex = 0;
        keyBuf = 0;
        lastSampleTimeMs = nowMillis;
        lastSyncRequestMillis = nowMillis;
        lastSyncRetryMillis = nowMillis;

        // ä¸€ç¬èµ¤ã§ç‚¹ç¯
        setLedColorFromProfile(&RedProfile);
        delay(100);

        // currentKeyState ã«å¿œã˜ã¦è¡¨ç¤º
        if (currentKeyState)
        {
          setLedColorFromProfile(&GreenProfile);
        }
        else
        {
          clearLed();
        }
      }

      else if (size == 1 && buf[0] == 0xFE)
      {
        pongReceived = true;

        long rtt = nowMillis - lastPingSendMillis;
        rttHistory[rttIndex] = rtt;
        rttIndex = (rttIndex + 1) % RTT_HISTORY_SIZE;
        pingRttMs = getAverageRtt();

        if (!fixedDelayLocked && !currentKeyState && (millis() - lastOnMillis > 1000))
        {
          if (pingRttMs <= RTT_THRESH_1)
            fixedDelayMs = DELAY_VERY_LOW;
          else if (pingRttMs <= RTT_THRESH_2)
            fixedDelayMs = DELAY_LOW;
          else if (pingRttMs <= RTT_THRESH_3)
            fixedDelayMs = DELAY_MID;
          else if (pingRttMs <= RTT_THRESH_4)
            fixedDelayMs = DELAY_HIGH;
          else if (pingRttMs <= RTT_THRESH_5)
            fixedDelayMs = DELAY_VERY_HIGH;
          else if (pingRttMs <= RTT_THRESH_6)
            fixedDelayMs = DELAY_VERY2_HIGH;
          else if (pingRttMs <= RTT_THRESH_7)
            fixedDelayMs = DELAY_VERY3_HIGH;
          else
            fixedDelayMs = DELAY_MAX;

          fixedDelayLocked = true;
        }

        lastPingMillis = nowMillis;
      }
    }
  }

  // PINGé€ä¿¡
  if (timeSynced && nowMillis - lastPingMillis > PING_INTERVAL)
  {
    if (!pongReceived)
    {
      if (!currentKeyState)
      { // ã‚­ãƒ¼é€ä¿¡ä¸­ã¯è¡¨ç¤ºã—ãªã„
        lostPingCount++;
        // Serial.printf("âš ï¸ Ping lost! Count: %d (last RTT=%ld ms)\n", lostPingCount, pingRttMs);
      }
      else
      {
        // ã‚­ãƒ¼é€ä¿¡ä¸­ã¯ã‚«ã‚¦ãƒ³ãƒˆã‚‚æ­¢ã‚ã‚‹
        lostPingCount = 0;
      }
    }
    pongReceived = false;

    byte ping = 0xFF;
    Udp.beginPacket(serverIP, SERVER_PORT);
    Udp.write(&ping, 1);
    Udp.endPacket();
    lastPingSendMillis = nowMillis;
  }

  // é…å»¶æ™‚é–“å†è¨ˆç®—
  if (timeSynced && nowMillis - lastDelayRecalcMillis >= ReCal_RTT)
  {
    lastDelayRecalcMillis = nowMillis;
    pingRttMs = getAverageRtt();

    if (!fixedDelayLocked)
    {
      if (pingRttMs <= RTT_THRESH_1)
        fixedDelayMs = DELAY_VERY_LOW;
      else if (pingRttMs <= RTT_THRESH_2)
        fixedDelayMs = DELAY_LOW;
      else if (pingRttMs <= RTT_THRESH_3)
        fixedDelayMs = DELAY_MID;
      else if (pingRttMs <= RTT_THRESH_4)
        fixedDelayMs = DELAY_HIGH;
      else if (pingRttMs <= RTT_THRESH_5)
        fixedDelayMs = DELAY_VERY_HIGH;
      else if (pingRttMs <= RTT_THRESH_6)
        fixedDelayMs = DELAY_VERY2_HIGH;
      else if (pingRttMs <= RTT_THRESH_7)
        fixedDelayMs = DELAY_VERY3_HIGH;
      else
        fixedDelayMs = DELAY_MAX;
    }
  }

  // ==== ã‚µãƒ¼ãƒå¿œç­”ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ¤œå‡º ====
  if (timeSynced && nowMillis - lastPingMillis >= dynamicTimeout)
  {
    timeSynced = false;
    blinkInterval = BLINK_INTERVAL_WIFI;
    fixedDelayLocked = false;
    // Serial.println("ã‚µãƒ¼ãƒã¨ã®æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€‚å¾…æ©ŸçŠ¶æ…‹ã«æˆ»ã‚Šã¾ã™ã€‚");
  }

  // 5ç§’ä»¥ä¸Šã‚­ãƒ¼æŠ¼ä¸‹ãŒãªã„å ´åˆã¯é…å»¶å†è©•ä¾¡ã‚’è¨±å¯
  if (timeSynced && !currentKeyState && (millis() - lastOnMillis >= 5000))
  {
    fixedDelayLocked = false;
  }

  // LEDç‚¹æ»…
  if (nowMillis - lastBlinkMillis >= blinkInterval)
  {
    ledState = !ledState;

    if (ledState)
    {
      setLedColorFromProfile(&GreenProfile);
    }
    else
    {
      clearLed();
    }

    lastBlinkMillis = nowMillis;
  }

  // WiFiåˆ‡æ–­æ¤œå‡º
  if (WiFi.status() != WL_CONNECTED)
  {
    wifiWasDisconnected = true;
    timeSynced = false;
    blinkInterval = BLINK_INTERVAL_WIFI;
    fixedDelayLocked = false;
  }

  // ==== SYNCå†é€ã®è‡ªå‹•åŒ– ====
  if (!timeSynced && WiFi.status() == WL_CONNECTED && millis() - lastSyncRetryMillis >= 5000)
  {
    syncCollecting = true;
    syncSampleIndex = 0;
    requestMillisSync();
    lastSyncRetryMillis = millis();
    // Serial.println("SYNCå†é€è¦æ±‚ã‚’é€ä¿¡ã—ã¾ã—ãŸ");
  }

  if (!timeSynced)
    return;

  // ONå®‰å…¨å¯¾ç­–
  if (currentKeyState && nowMillis - lastOnMillis > MAX_ON_DURATION)
  {
    currentKeyState = false;
    uint64_t opTimeMs = nowMillis + delayOffsetMs + fixedDelayMs;
    sendKeyPacket(false, trxCode, opTimeMs);
  }

  if (fixedDelayLocked && millis() > fixedDelayLockUntil)
  {
    fixedDelayLocked = false;
  }

  delay(1);
}

// ==== WiFiæ¥ç¶š ====
bool connectToWiFi()
{

  WiFiProfile profile = wifiProfiles[activeProfileIndex]; // â† é¸æŠæ¸ˆã¿ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã ã‘ä½¿ã†ï¼
  if (!profile.isApMode && profile.hostname && strlen(profile.hostname) > 0)
  {
    WiFi.setHostname(profile.hostname);
  }
  if (profile.hasIP)
  {
    WiFi.config(profile.localIP, profile.gateway, profile.subnet);
  }
  esp_wifi_set_ps(WIFI_PS_NONE);
  WiFi.begin(profile.ssid, profile.password);

  if (profile.isApMode)
  {
    esp_wifi_set_max_tx_power(84);
  }

  for (int t = 0; t < 60; t++)
  {
    if (WiFi.status() == WL_CONNECTED)
    {
      serverIP = profile.serverIP;
      int rssi = WiFi.RSSI();
      dynamicTimeout = DEFAULT_TIMEOUT;

      // Serial.printf("âœ… æ¥ç¶šæˆåŠŸ: SSID=%s, IP=%s\n", profile.ssid, WiFi.localIP().toString().c_str());
      // Serial.printf("âœ… æ¥ç¶šæˆåŠŸ: SSID=%s", profile.ssid);
      return true;
    }
    if (WiFi.status() == WL_NO_SSID_AVAIL)
    {
      // Serial.println("â³ SSIDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å†è©¦è¡Œä¸­...");
    }
    delay(500);
  }

  // Serial.printf("âŒ æ¥ç¶šå¤±æ•—: SSID=%s, IP=%s, status=%d\n", profile.ssid, WiFi.localIP().toString().c_str(), WiFi.status());

  return false;
}

// ==== SYNCè¦æ±‚ï¼ˆæ™‚åˆ»è£œæ­£å°‚ç”¨ï¼‰ ====
void requestMillisSync()
{
  lastSyncRequestMillis = millis();
  lastPingSendMillis = lastSyncRequestMillis;
  byte pkt[5] = {
      0xE0,
      (byte)((lastSyncRequestMillis >> 24) & 0xFF),
      (byte)((lastSyncRequestMillis >> 16) & 0xFF),
      (byte)((lastSyncRequestMillis >> 8) & 0xFF),
      (byte)(lastSyncRequestMillis & 0xFF)};
  Udp.beginPacket(serverIP, SERVER_PORT);
  Udp.write(pkt, 5);
  Udp.endPacket();
}

// ==== ã‚­ãƒ¼ãƒ‘ã‚±ãƒƒãƒˆé€ä¿¡ ====
void sendKeyPacket(bool isOn, byte trxSel, uint64_t opTimeMs)
{
  byte pkt[10];
  pkt[0] = isOn ? 0x01 : 0x00;
  pkt[1] = trxSel;
  for (int i = 0; i < 8; i++)
    pkt[2 + i] = (opTimeMs >> (56 - i * 8)) & 0xFF;

  for (int i = 0; i < keyRepeatCount; i++)
  {
    if (!Udp.beginPacket(serverIP, SERVER_PORT))
      return;
    Udp.write(pkt, 10);
    Udp.endPacket();
#ifdef M5ATOMLite
    yield();
#elif M5ATOMS3Lite
    // delay(1);
    taskYIELD();
#endif
  }

  if (isOn)
  {
    setLedColorFromProfile(&RedProfile);
  }
  else
  {
    clearLed();
  }
}

void flashRedBeforeRestart()
{
  for (int i = 0; i < 3; i++)
  {
    setLedColorFromProfile(&RedProfile);
    delay(100);
    clearLed();
    delay(100);
  }
}

void saveProfileIndexToEEPROM(int index)
{
  EEPROM.write(EEPROM_ADDR_PROFILE_INDEX, index);
  EEPROM.commit();
}

int loadProfileIndexFromEEPROM()
{
  byte val = EEPROM.read(EEPROM_ADDR_PROFILE_INDEX);
  if (val < MAX_WIFI_PROFILES)
    return val;
  return 0; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
}

bool loadWiFiProfilesFromSD()
{
  File file = SD.open(SD_Filename);
  if (!file)
    return false;

  WiFiProfile temp;
  ColorProfile *color = &cyanProfile;
  profileCount = 0;
  bool hasData = false; // â† è¿½åŠ ï¼

  while (file.available())
  {
    String line = file.readStringUntil('\n');
    line.trim();

    if (line.length() == 0 || line.startsWith("#"))
      continue;

    if (line.startsWith("[Profile]"))
    {
      if (hasData && temp.ssid && strlen(temp.ssid) > 0 && temp.password && strlen(temp.password) > 0 && profileCount < MAX_WIFI_PROFILES)
      {
        wifiProfiles[profileCount] = temp;
        temp.color = color;
        wifiProfiles[profileCount].color = color;
        /*Serial.printf("âœ… ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«[%d] èª­ã¿è¾¼ã¿: SSID=%s, MODE=%s, COLOR=%s\n",
                      profileCount,
                      temp.ssid,
                      temp.isApMode ? "AP" : "STA",
                      color->name);
                      */
        profileCount++;
      }
      else if (hasData)
      {
        // Serial.println("âš ï¸ ç„¡åŠ¹ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆSSIDã¾ãŸã¯PASSãªã—ï¼‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ");
      }

      temp = WiFiProfile();
      color = &cyanProfile;
      hasData = false;
    }
    else if (line.startsWith("SSID="))
    {
      temp.ssid = strdup(line.substring(5).c_str());
      hasData = true;
    }
    else if (line.startsWith("PASS="))
    {
      temp.password = strdup(line.substring(5).c_str());
      hasData = true;
    }
    else if (line.startsWith("IP="))
      temp.localIP.fromString(line.substring(3));
    else if (line.startsWith("GW="))
      temp.gateway.fromString(line.substring(3));
    else if (line.startsWith("MASK="))
      temp.subnet.fromString(line.substring(5));
    else if (line.startsWith("SERVER="))
      temp.serverIP.fromString(line.substring(7));
    else if (line.startsWith("MODE="))
      temp.isApMode = (line.substring(5) == "AP");
    else if (line.startsWith("HASIP="))
      temp.hasIP = (line.substring(6) == "IP");
    else if (line.startsWith("COLOR="))
    {
      String c = line.substring(6);
      if (c == "Magenta")
        color = &MagentaProfile;
      else if (c == "Yellow")
        color = &yellowProfile;
      else if (c == "Cyan")
        color = &cyanProfile;
      else if (c == "Red")
        color = &RedProfile;
      else if (c == "Blue")
        color = &BlueProfile;
      else if (c == "Green")
        color = &GreenProfile;
      else if (c == "White")
        color = &WhiteProfile;
    }
    else if (line.startsWith("HOSTNAME="))
    {
      temp.hostname = strdup(line.substring(9).c_str());
    }
    else if (line.startsWith("SERVERHOSTNAME="))
    {
      temp.serverhostname = strdup(line.substring(15).c_str());
    }
  }

  // æœ€å¾Œã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜
  if (hasData && temp.ssid && strlen(temp.ssid) > 0 && temp.password && strlen(temp.password) > 0 && profileCount < MAX_WIFI_PROFILES)
  {
    wifiProfiles[profileCount] = temp;
    wifiProfiles[profileCount].color = color;
    /*Serial.printf("âœ… ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«[%d] èª­ã¿è¾¼ã¿: SSID=%s, MODE=%s, COLOR=%s\n",
                  profileCount,
                  temp.ssid,
                  temp.isApMode ? "AP" : "STA",
                  color->name);
                  */
    profileCount++;
  }
  else if (hasData)
  {
    // Serial.println("âš ï¸ æœ€å¾Œã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãŒç„¡åŠ¹ï¼ˆSSIDã¾ãŸã¯PASSãªã—ï¼‰ã ã£ãŸãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ");
  }

  file.close();
  // Serial.printf("ğŸ“¦ SDã‹ã‚‰èª­ã¿è¾¼ã‚“ã ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ•°: %d\n", profileCount);
  return profileCount > 0;
}

void saveWiFiProfileToEEPROM(const WiFiProfile &src, int index)
{
  if (!src.ssid || strlen(src.ssid) == 0 || !src.password || strlen(src.password) == 0)
  {
    // Serial.printf("âŒ saveWiFiProfileToEEPROM: ç„¡åŠ¹ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆindex=%dï¼‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\n", index);
    return;
  }

  WiFiProfileEEPROM dst;
  memset(&dst, 0, sizeof(dst));
  dst.magic = PROFILE_MAGIC;
  strncpy(dst.ssid, src.ssid, MAX_SSID_LEN);
  strncpy(dst.password, src.password, MAX_PASS_LEN);
  strncpy(dst.hostname, src.hostname, MAX_HOSTNAME_LEN);
  strncpy(dst.serverhostname, src.serverhostname, MAX_HOSTNAME_LEN);

  for (int i = 0; i < 4; i++)
  {
    dst.localIP[i] = src.localIP[i];
    dst.gateway[i] = src.gateway[i];
    dst.subnet[i] = src.subnet[i];
    dst.serverIP[i] = src.serverIP[i];
  }

  dst.isApMode = src.isApMode;
  dst.hasIP = src.hasIP;
  if (src.color == &cyanProfile)
    dst.colorId = 0;
  else if (src.color == &MagentaProfile)
    dst.colorId = 1;
  else if (src.color == &yellowProfile)
    dst.colorId = 2;
  else if (src.color == &RedProfile)
    dst.colorId = 3;
  else if (src.color == &BlueProfile)
    dst.colorId = 4;
  else if (src.color == &GreenProfile)
    dst.colorId = 5;
  else if (src.color == &WhiteProfile)
    dst.colorId = 6;
  else
    dst.colorId = 0;

  int addr = EEPROM_ADDR_PROFILE_BASE + index * sizeof(WiFiProfileEEPROM);
  // Serial.printf("ğŸ’¾ æ›¸ãè¾¼ã¿ index=%d, addr=%d, SSID=%s\n", index, addr, src.ssid);
  EEPROM.put(addr, dst);
  EEPROM.commit();
}

bool loadWiFiProfileFromEEPROM(WiFiProfile &dst, int index)
{
  WiFiProfileEEPROM raw;
  int addr = EEPROM_ADDR_PROFILE_BASE + index * sizeof(WiFiProfileEEPROM);
  EEPROM.get(addr, raw);

  // Serial.printf("ğŸ“– èª­ã¿è¾¼ã¿ index=%d, addr=%d, magic=0x%02X\n", index, addr, raw.magic);

  if (raw.magic != PROFILE_MAGIC)
  {
    // Serial.printf("âŒ ç„¡åŠ¹ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« index=%dï¼ˆmagic=0x%02Xï¼‰\n", index, raw.magic);
    return false; // â† if ã®ä¸­ã«å…¥ã‚Œã‚‹ï¼
  }

  dst.ssid = strdup(raw.ssid);
  dst.password = strdup(raw.password);
  dst.localIP = IPAddress(raw.localIP);
  dst.gateway = IPAddress(raw.gateway);
  dst.subnet = IPAddress(raw.subnet);
  dst.serverIP = IPAddress(raw.serverIP);
  dst.isApMode = raw.isApMode;
  dst.hasIP = raw.hasIP;
  dst.hostname = strdup(raw.hostname);
  dst.serverhostname = strdup(raw.serverhostname);

  switch (raw.colorId)
  {
  case 0:
    dst.color = &cyanProfile;
    break;
  case 1:
    dst.color = &MagentaProfile;
    break;
  case 2:
    dst.color = &yellowProfile;
    break;
  case 3:
    dst.color = &RedProfile;
    break;
  case 4:
    dst.color = &BlueProfile;
    break;
  case 5:
    dst.color = &GreenProfile;
    break;
  case 6:
    dst.color = &WhiteProfile;
    break;
  default:
    // Serial.printf("âš ï¸ EEPROMã® colorId=%d ã¯ä¸æ­£ã§ã™ã€‚Red ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™\n", raw.colorId);
    dst.color = &RedProfile;
    break;
  }

  return true;
}

void clearEEPROM()
{
  for (int i = 0; i < EEPROM_SIZE; i++)
    EEPROM.write(i, 0xFF);
  EEPROM.commit();
  delay(100);
}

bool restoreProfilesFromEEPROM()
{
  profileCount = 0;
  for (int i = 0; i < MAX_WIFI_PROFILES; i++)
  {
    if (loadWiFiProfileFromEEPROM(wifiProfiles[i], i))
    {
      profileCount++;
      // Serial.printf("âœ… EEPROMã‹ã‚‰ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«[%d] ã‚’å¾©å…ƒ: SSID=%s\n", i, wifiProfiles[i].ssid);
    }
  }
  // Serial.printf("ğŸ“Š å¾©å…ƒã•ã‚ŒãŸãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ•°: %d\n", profileCount);
  return profileCount > 0;
}

void getserverIP()
{
  WiFiProfile &profile = wifiProfiles[activeProfileIndex];

  if (!profile.hasIP && profile.serverhostname != nullptr && strlen(profile.serverhostname) > 0)
  {
    if (!MDNS.begin(profile.hostname))
    {

      // Serial.println("âŒ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ mDNSåˆæœŸåŒ–å¤±æ•—");
      return;
    }
    // Serial.println("âœ… ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ mDNSåˆæœŸåŒ–æˆåŠŸ");
    // Serial.print("ğŸ“¡ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆIP: ");
    // Serial.println(WiFi.localIP());
    String hostname = profile.serverhostname;
    delay(1000);
    if (!hostname.endsWith(".local"))
    {
      hostname += ".local";
    }

    // Serial.print("ğŸ” mDNSã‚¯ã‚¨ãƒªä¸­: ");
    // Serial.println(hostname);

    String queryName = hostname;
    queryName.replace(".local", "");

    IPAddress resolved;
    for (int i = 0; i < HOSTNAME_RESTIME; i++)
    {
      resolved = MDNS.queryHost(queryName);
      if (resolved != INADDR_NONE)
        break;
      // Serial.println("â³ mDNSãƒªãƒˆãƒ©ã‚¤ä¸­...");
      delay(1000);
    }
    if (resolved == INADDR_NONE)
    {
      // Serial.println("âŒ mDNSã‚¯ã‚¨ãƒªå¤±æ•—ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼‰");
      return;
    }

    serverIP = resolved;
    // Serial.print("âœ… mDNSã§è§£æ±º: ");
    // Serial.println(serverIP);
  }
  else
  {
    serverIP = profile.serverIP;
  }
}

void setLedColorFromProfile(ColorProfile *color)
{
  if (!color)
    return;
  setLedColor(color->r, color->g, color->b);
}

void flashLedProfile(ColorProfile *color, int durationMs = 200, int repeat = 1)
{
  if (!color)
    return;
  for (int i = 0; i < repeat; i++)
  {
    setLedColorFromProfile(color);
    delay(durationMs);
    setLedColor(0, 0, 0); // æ¶ˆç¯
    delay(durationMs);
  }
}

void flashOnce(ColorProfile *color, int durationMs)
{
  if (!color)
    return;
  setLedColorFromProfile(color);
  delay(durationMs);
  setLedColor(0, 0, 0); // æ¶ˆç¯
}

void initLed()
{
  pixels.begin();
  pixels.setBrightness(50);
}

void setLedFromProfileIndex(int index)
{
  if (index >= 0 && index < profileCount)
    setLedColorFromProfile(wifiProfiles[index].color);
}

void clearLed()
{
  pixels.clear();
  pixels.show();
}