/*=============================================================================*
 * M5Stadk_RemoteKeyerWifi クライアント用ファームウェア Ver1.0
 * M5Stack ATOM Lite 対応
 * Copyright (C) 2025- JI1ORE
 *=============================================================================*/
#include <WiFi.h>
#include <WiFiUdp.h>
#include <Adafruit_NeoPixel.h>

// ==== ピン定義 ====
const int KEY_PIN = 19;
const int LED_PIN = 27;
#define NUMPIXELS 1

// ==== UDP設定 ====
#define LOCAL_PORT 8888
#define SERVER_PORT 8888
WiFiUDP Udp;

Adafruit_NeoPixel pixels(NUMPIXELS, LED_PIN, NEO_GRB + NEO_KHZ800);

// ==== WiFi設定 ====
struct WiFiProfile
{
  const char *ssid;
  const char *password;
  IPAddress localIP;
  IPAddress gateway;
  IPAddress subnet;
  IPAddress serverIP;
};

WiFiProfile wifiProfiles[] = {
    {"iPhone1", "xxxxxxxx", IPAddress(172, 20, 10, 6), IPAddress(172, 20, 10, 1), IPAddress(255, 255, 255, 240), IPAddress(172, 20, 10, 5)},
    {"LAN-1", "xxxxxxxx", IPAddress(192, 168, 0, 51), IPAddress(192, 168, 0, 1), IPAddress(255, 255, 255, 0), IPAddress(192, 168, 0, 50)}};

const int profileCount = sizeof(wifiProfiles) / sizeof(wifiProfiles[0]);
IPAddress serverIP;

// ==== 動作パラメータ ====
unsigned long MAX_ON_DURATION = 3000;
const int PING_INTERVAL = 1000;
const int ReCal_RTT = 5000;
int keyRepeatCount = 2; // 即時変化パケットの重複送付回数

// ==== 遅延分類 ====
// ping返送時間(msec)
const int RTT_THRESH_1 = 5;
const int RTT_THRESH_2 = 10;
const int RTT_THRESH_3 = 25;
const int RTT_THRESH_4 = 50;
const int RTT_THRESH_5 = 75;
const int RTT_THRESH_6 = 100;
const int RTT_THRESH_7 = 200;

// ping返送時間間隔ごとの遅延時間定義(msec)
const int DELAY_VERY_LOW = 40;    // RTT_THRESH_1以下
const int DELAY_LOW = 50;         // RTT_THRESH_2以下
const int DELAY_MID = 75;         // RTT_THRESH_3以下
const int DELAY_HIGH = 100;       // RTT_THRESH_4以下
const int DELAY_VERY_HIGH = 125;  // RTT_THRESH_5以下
const int DELAY_VERY2_HIGH = 150; // RTT_THRESH_6以下
const int DELAY_VERY3_HIGH = 250; // RTT_THRESH_7以下
const int DELAY_MAX = 500;        // RTT_THRESH_7超

const unsigned long BLINK_INTERVAL_WIFI = 1000;
const unsigned long BLINK_INTERVAL_SYNC = 300;
unsigned long blinkInterval = BLINK_INTERVAL_WIFI;
unsigned long lastSyncRequestMillis = 0;

// ==== 状態管理 ====
volatile bool immediateSendRequested = false;
volatile bool keyState = false;
volatile unsigned long lastIsrMicros = 0;

unsigned long lastSendMicros = 0;
unsigned long lastOnMillis = 0;
unsigned long lastBlinkMillis = 0;
unsigned long lastPingMillis = 0;
unsigned long lastPingSendMillis = 0;
long delayOffsetMs = 0;
bool timeSynced = false;
bool ledState = false;
unsigned long dynamicTimeout = 8000;
static unsigned long lastDelayRecalcMillis = 0;

int fixedDelayMs = 50;
bool fixedDelayLocked = false;
bool wifiWasDisconnected = false;
bool currentKeyState = false;

int lostPingCount = 0;
bool pongReceived = true; // pong応答が来たかどうか

const unsigned long DEFAULT_TIMEOUT_MIN = 4000;
const unsigned long DEFAULT_TIMEOUT_MAX = 12000;

// ==== サンプリング用変数 ====
static byte keyBuf = 0;
static int sampleIndex = 0;
static unsigned long sampleStartTimeMs = 0;
static unsigned long lastSampleTimeMs = 0;
const int SAMPLE_SEND_DUP_CNT = 2; // サンプリングパケットの重複送付回数
const int SAMPLE_INTERVAL_MS = 2;  // サンプリングの周期(msec)
const int SAMPLE_SEND_AMNT = 8;    // サンプリングパケットの送付サイズ(変更時は送付パケットの修正が必要)
const int PACKET_SEND_INTERVAL_MS = SAMPLE_INTERVAL_MS * SAMPLE_SEND_AMNT;

// ==== 関数プロトタイプ ====
bool connectToWiFi();
void requestMillisSync();
void sendKeyPacket(bool isOn, byte trxSel, uint64_t opTimeMs);

// ==== RTT履歴 ====
const int RTT_HISTORY_SIZE = 5;
long rttHistory[RTT_HISTORY_SIZE] = {0};
int rttIndex = 0;
long pingRttMs = 0;

long getAverageRtt()
{
  long sum = 0;
  for (int i = 0; i < RTT_HISTORY_SIZE; i++)
    sum += rttHistory[i];
  return sum / RTT_HISTORY_SIZE;
}

// ==== 割り込み処理 ====
const unsigned long DEBOUNCE_US = 1000;

void keyISR()
{
  if (!timeSynced)
    return;
  unsigned long now = micros();
  if (now - lastIsrMicros < DEBOUNCE_US)
    return;
  lastIsrMicros = now;
  keyState = (digitalRead(KEY_PIN) == LOW);
  immediateSendRequested = true;
}

// ==== 初期化 ====
void setup()
{
  Serial.begin(115200);
  pinMode(KEY_PIN, INPUT_PULLUP);
  pixels.begin();
  pixels.clear();
  pixels.show();

  attachInterrupt(digitalPinToInterrupt(KEY_PIN), keyISR, CHANGE);

  connectToWiFi();
  Udp.begin(LOCAL_PORT);
  requestMillisSync();
  lastPingMillis = millis();
}

// ==== LED制御用関数 ====
void setLedColor(uint8_t r, uint8_t g, uint8_t b)
{
  pixels.setPixelColor(0, pixels.Color(r, g, b));
  pixels.show();
}

// ==== メインループ ====
void loop()
{
  unsigned long nowMicros = micros();
  unsigned long nowMillis = millis();
  byte trxCode = 0x01; //固定する

  // ==== SYNC再送の強化（初回＋周期） ====

  static bool syncRequested = false;
  static unsigned long lastSyncRetryMillis = 0;

  if (!timeSynced && WiFi.status() == WL_CONNECTED)
  {
    if (!syncRequested || millis() - lastSyncRetryMillis >= 5000)
    {
      requestMillisSync();
      syncRequested = true;
      lastSyncRetryMillis = millis();
      Serial.println("SYNC要求を送信しました");
    }
  }

  // 即時送信処理
  bool doSend = false;
  bool sendState = false;
  noInterrupts();
  if (immediateSendRequested)
  {
    doSend = true;
    sendState = keyState;
    delay(2);
    immediateSendRequested = false;
  }
  interrupts();

  if (doSend && timeSynced)
  {
    fixedDelayLocked = true; // ① 遅延時間の再評価を防止

    currentKeyState = sendState;
    uint64_t opTimeMs = nowMillis + delayOffsetMs + fixedDelayMs; // ② opTimeMsを1回だけ計算

    int repeat = currentKeyState ? 1 : 3; // OFF時は3回送信
    for (int i = 0; i < repeat; i++)
    {
      sendKeyPacket(currentKeyState, trxCode, opTimeMs); // opTimeMsは固定
      delay(1);                                          // WiFiスタック安定化（必要に応じて）
    }

    lastSendMicros = nowMicros;
    lastOnMillis = currentKeyState ? nowMillis : lastOnMillis;
  }

  // ==== SAMPLE_INTERVAL_MSごとのサンプリング処理 ====
  if (timeSynced && millis() - lastSampleTimeMs >= SAMPLE_INTERVAL_MS)
  {
    lastSampleTimeMs = millis();
    bool down = (digitalRead(KEY_PIN) == LOW);
    if (sampleIndex == 0)
    {
      sampleStartTimeMs = millis();
      keyBuf = 0; // ← 初期化をここに移動
    }
    if (down)
      keyBuf |= (1 << sampleIndex);
    sampleIndex++;

    if (sampleIndex >= SAMPLE_SEND_AMNT)
    {
      // byte trxCode = (digitalRead(TRX_PIN) == LOW) ? 0x02 : 0x01;
      trxCode = 0x01;
      byte pkt[13];
      pkt[0] = trxCode;
      pkt[1] = keyBuf;
      pkt[2] = (sampleStartTimeMs >> 16) & 0xFF;
      pkt[3] = (sampleStartTimeMs >> 8) & 0xFF;
      pkt[4] = sampleStartTimeMs & 0xFF;
      for (int i = 0; i < 8; i++)
        pkt[5 + i] = i * SAMPLE_INTERVAL_MS;

      for (int i = 0; i < SAMPLE_SEND_DUP_CNT; i++)
      {
        Udp.beginPacket(serverIP, SERVER_PORT);
        Udp.write(pkt, 13);
        Udp.endPacket();
        delay(1); // WiFi安定化
      }

      sampleIndex = 0;
    }
  }

  // UDP受信処理
  int size = Udp.parsePacket();
  if (size > 0)
  {
    byte buf[12];
    int len = Udp.read(buf, size);

    if (size == 9 && buf[0] == 0xE1)
    {
      uint64_t serverRecvMs = 0;
      for (int i = 0; i < 8; i++)
        serverRecvMs = (serverRecvMs << 8) | buf[1 + i];

      long offset = (long)serverRecvMs - (long)nowMillis;

      // === サーバー再起動検出 ===
      if (offset < -5000)
      { // 5秒以上ズレていたら異常と判断
        Serial.println("サーバーの起動時間が大幅に巻き戻りました。クライアントを再起動します。");
        ESP.restart(); // ← ESP32をソフトリセット
        return;
      }

      delayOffsetMs = offset;

      // 以下、通常のSYNC処理（初期化など）
      timeSynced = true;
      // RTTに応じて初期遅延を設定（固定化）
      if (pingRttMs <= RTT_THRESH_1)
        fixedDelayMs = DELAY_VERY_LOW;
      else if (pingRttMs <= RTT_THRESH_2)
        fixedDelayMs = DELAY_LOW;
      else if (pingRttMs <= RTT_THRESH_3)
        fixedDelayMs = DELAY_MID;
      else if (pingRttMs <= RTT_THRESH_4)
        fixedDelayMs = DELAY_HIGH;
      else if (pingRttMs <= RTT_THRESH_5)
        fixedDelayMs = DELAY_VERY_HIGH;
      else if (pingRttMs <= RTT_THRESH_6)
        fixedDelayMs = DELAY_VERY2_HIGH;
      else if (pingRttMs <= RTT_THRESH_7)
        fixedDelayMs = DELAY_VERY3_HIGH;
      else
        fixedDelayMs = DELAY_MAX;

      fixedDelayLocked = true; // 通常はロックして安定運用

      lastPingMillis = nowMillis;
      lastPingSendMillis = nowMillis;
      blinkInterval = BLINK_INTERVAL_SYNC;

      fixedDelayLocked = false;
      rttIndex = 0;
      for (int i = 0; i < RTT_HISTORY_SIZE; i++)
        rttHistory[i] = 0;

      sampleIndex = 0;
      keyBuf = 0;
      lastSampleTimeMs = nowMillis;
      lastSyncRequestMillis = nowMillis;
      lastSyncRetryMillis = nowMillis;

      // 一瞬赤で点灯
      pixels.setPixelColor(0, pixels.Color(255, 0, 0)); // 赤
      pixels.show();
      delay(100);

      // currentKeyState に応じて表示
      if (currentKeyState)
      {
        pixels.setPixelColor(0, pixels.Color(0, 255, 0)); // 緑
      }
      else
      {
        pixels.clear(); // 消灯
      }
      pixels.show();
    }

    else if (size == 1 && buf[0] == 0xFE)
    {
      pongReceived = true;

      long rtt = nowMillis - lastPingSendMillis;
      rttHistory[rttIndex] = rtt;
      rttIndex = (rttIndex + 1) % RTT_HISTORY_SIZE;
      pingRttMs = getAverageRtt();

      if (!fixedDelayLocked)
      {
        if (pingRttMs <= RTT_THRESH_1)
          fixedDelayMs = DELAY_VERY_LOW;
        else if (pingRttMs <= RTT_THRESH_2)
          fixedDelayMs = DELAY_LOW;
        else if (pingRttMs <= RTT_THRESH_3)
          fixedDelayMs = DELAY_MID;
        else if (pingRttMs <= RTT_THRESH_4)
          fixedDelayMs = DELAY_HIGH;
        else if (pingRttMs <= RTT_THRESH_5)
          fixedDelayMs = DELAY_VERY_HIGH;
        else if (pingRttMs <= RTT_THRESH_6)
          fixedDelayMs = DELAY_VERY2_HIGH;
        else if (pingRttMs <= RTT_THRESH_7)
          fixedDelayMs = DELAY_VERY3_HIGH;
        else
          fixedDelayMs = DELAY_MAX;

        fixedDelayLocked = true;
      }

      lastPingMillis = nowMillis;
    }
  }

  // PING送信
  if (timeSynced && nowMillis - lastPingMillis > PING_INTERVAL)
  {
    if (!pongReceived)
    {
      if (!currentKeyState)
      { // キー送信中は表示しない
        lostPingCount++;
        // Serial.printf("⚠️ Ping lost! Count: %d (last RTT=%ld ms)\n", lostPingCount, pingRttMs);
      }
      else
      {
        // キー送信中はカウントも止める
        lostPingCount = 0;
      }
    }
    pongReceived = false;

    byte ping = 0xFF;
    Udp.beginPacket(serverIP, SERVER_PORT);
    Udp.write(&ping, 1);
    Udp.endPacket();
    lastPingSendMillis = nowMillis;
  }

  // 遅延時間再計算
  if (timeSynced && nowMillis - lastDelayRecalcMillis >= ReCal_RTT)
  {
    lastDelayRecalcMillis = nowMillis;
    pingRttMs = getAverageRtt();

    if (!fixedDelayLocked)
    {
      if (pingRttMs <= RTT_THRESH_1)
        fixedDelayMs = DELAY_VERY_LOW;
      else if (pingRttMs <= RTT_THRESH_2)
        fixedDelayMs = DELAY_LOW;
      else if (pingRttMs <= RTT_THRESH_3)
        fixedDelayMs = DELAY_MID;
      else if (pingRttMs <= RTT_THRESH_4)
        fixedDelayMs = DELAY_HIGH;
      else if (pingRttMs <= RTT_THRESH_5)
        fixedDelayMs = DELAY_VERY_HIGH;
      else if (pingRttMs <= RTT_THRESH_6)
        fixedDelayMs = DELAY_VERY2_HIGH;
      else if (pingRttMs <= RTT_THRESH_7)
        fixedDelayMs = DELAY_VERY3_HIGH;
      else
        fixedDelayMs = DELAY_MAX;
    }
  }

  // ==== サーバ応答タイムアウト検出 ====
  if (timeSynced && nowMillis - lastPingMillis >= dynamicTimeout)
  {
    timeSynced = false;
    blinkInterval = BLINK_INTERVAL_WIFI;
    fixedDelayLocked = false;
    Serial.println("サーバとの接続タイムアウト。待機状態に戻ります。");
  }

  // 5秒以上キー押下がない場合は遅延再評価を許可
  if (timeSynced && !currentKeyState && (millis() - lastOnMillis >= 5000))
  {
    fixedDelayLocked = false;
  }

  // LED点滅
  if (nowMillis - lastBlinkMillis >= blinkInterval)
  {
    ledState = !ledState;
    // digitalWrite(LED_PIN, ledState ? HIGH : LOW);
    if (ledState)
    {
      pixels.setPixelColor(0, pixels.Color(0, 255, 0)); // 緑
    }
    else
    {
      pixels.clear(); // 消灯
    }
    pixels.show();
    lastBlinkMillis = nowMillis;
  }

  // WiFi切断検出
  if (WiFi.status() != WL_CONNECTED)
  {
    wifiWasDisconnected = true;
    timeSynced = false;
    blinkInterval = BLINK_INTERVAL_WIFI;
    fixedDelayLocked = false;
  }

  // ==== SYNC再送の自動化 ====
  if (!timeSynced && WiFi.status() == WL_CONNECTED && millis() - lastSyncRetryMillis >= 5000)
  {
    requestMillisSync();
    lastSyncRetryMillis = millis();
    Serial.println("SYNC再送要求を送信しました");
  }

  if (!timeSynced)
    return;

  // ON安全対策
  if (currentKeyState && nowMillis - lastOnMillis > MAX_ON_DURATION)
  {
    currentKeyState = false;
    uint64_t opTimeMs = nowMillis + delayOffsetMs + fixedDelayMs;
    sendKeyPacket(false, trxCode, opTimeMs);
  }
}

// ==== WiFi接続 ====
bool connectToWiFi()
{
  for (int i = 0; i < profileCount; i++)
  {
    WiFiProfile profile = wifiProfiles[i]; // ← & を外して構文を簡潔に
    WiFi.config(profile.localIP, profile.gateway, profile.subnet);
    WiFi.begin(profile.ssid, profile.password);
    for (int t = 0; t < 10; t++)
    {
      if (WiFi.status() == WL_CONNECTED)
      {
        serverIP = profile.serverIP;
        int rssi = WiFi.RSSI();
        dynamicTimeout = constrain(map(rssi, -90, -30, DEFAULT_TIMEOUT_MAX, DEFAULT_TIMEOUT_MIN),
                                   DEFAULT_TIMEOUT_MIN, DEFAULT_TIMEOUT_MAX);
        return true;
      }
      delay(500);
    }
  }
  return false;
}

// ==== SYNC要求（時刻補正専用） ====
void requestMillisSync()
{
  lastSyncRequestMillis = millis();
  lastPingSendMillis = lastSyncRequestMillis;
  byte pkt[5] = {
      0xE0,
      (byte)((lastSyncRequestMillis >> 24) & 0xFF),
      (byte)((lastSyncRequestMillis >> 16) & 0xFF),
      (byte)((lastSyncRequestMillis >> 8) & 0xFF),
      (byte)(lastSyncRequestMillis & 0xFF)};
  Udp.beginPacket(serverIP, SERVER_PORT);
  Udp.write(pkt, 5);
  Udp.endPacket();
}

// ==== キーパケット送信 ====
void sendKeyPacket(bool isOn, byte trxSel, uint64_t opTimeMs)
{
  byte pkt[10];
  pkt[0] = isOn ? 0x01 : 0x00;
  pkt[1] = trxSel;
  for (int i = 0; i < 8; i++)
    pkt[2 + i] = (opTimeMs >> (56 - i * 8)) & 0xFF;

  for (int i = 0; i < keyRepeatCount; i++)
  {
    if (!Udp.beginPacket(serverIP, SERVER_PORT))
      return;
    Udp.write(pkt, 10);
    Udp.endPacket();
    yield();
  }


  if (isOn)
  {
    pixels.setPixelColor(0, pixels.Color(255, 0, 0)); // 赤
  }
  else
  {
    pixels.clear();
  }
  pixels.show();
}
