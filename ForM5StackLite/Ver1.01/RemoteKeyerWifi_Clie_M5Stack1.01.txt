/*=============================================================================*
 * M5Stadk_RemoteKeyerWifi ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”¨ãƒ•ã‚¡ãƒ¼ãƒ ã‚¦ã‚§ã‚¢  Ver1.011
 * M5Stack ATOM Lite å¯¾å¿œ
 * Wifiãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠå¯¾å¿œ
 * ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆé€šä¿¡å¯¾å¿œ
 * 2025/12/08 å‡¦ç†å®‰å®šåŒ–ã®ãŸã‚ã®ä¿®æ­£
 * Copyright (C) 2025- JI1ORE
 *=============================================================================*/
#include <WiFi.h>
#include <WiFiUdp.h>
#include <Adafruit_NeoPixel.h>

// ==== ãƒ”ãƒ³å®šç¾© ====
const int KEY_PIN = 19;
const int LED_PIN = 27;
#define NUMPIXELS 1
#define BUTTON_PIN 39

// ==== è‰²è¨­å®š ====
struct ColorProfile
{
  const char *name;
  uint8_t r;
  uint8_t g;
  uint8_t b;
};

ColorProfile MagentaProfile = {"Magenta", 255, 0, 255};
ColorProfile yellowProfile = {"Yellow", 255, 255, 0};
ColorProfile cyanProfile = {"Cyan", 0, 255, 255};

// ==== WiFiè¨­å®š ====
struct WiFiProfile
{
  const char *ssid;
  const char *password;
  IPAddress localIP;
  IPAddress gateway;
  IPAddress subnet;
  IPAddress serverIP;
  bool isApMode; // APæ¥ç¶šã‹ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆæ¥ç¶šã‹
  ColorProfile *color;
};


WiFiProfile wifiProfiles[] = {
    {"LAN-1", "xxxxxxxx", IPAddress(192, 168, 0, 51), IPAddress(192, 168, 0, 1), IPAddress(255, 255, 255, 0), IPAddress(192, 168, 0, 50), false, &cyanProfile},
    {"iPhone1", "xxxxxxxx", IPAddress(172, 20, 10, 6), IPAddress(172, 20, 10, 1), IPAddress(255, 255, 255, 240), IPAddress(172, 20, 10, 5), false, &MagentaProfile},
    {"RemoteKeyer-AP1", "password123", IPAddress(192, 168, 40, 2), IPAddress(192, 168, 40, 1), IPAddress(255, 255, 255, 0), IPAddress(192, 168, 40, 1), true, &yellowProfile}};

const int profileCount = sizeof(wifiProfiles) / sizeof(wifiProfiles[0]);
IPAddress serverIP;

// ==== UDPè¨­å®š ====
#define LOCAL_PORT 8888
#define SERVER_PORT 8888
WiFiUDP Udp;

Adafruit_NeoPixel pixels(NUMPIXELS, LED_PIN, NEO_GRB + NEO_KHZ800);

// ==== å‹•ä½œãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ====
unsigned long MAX_ON_DURATION = 3000;
const int PING_INTERVAL = 5000;
const int ReCal_RTT = 5000;
int keyRepeatCount = 2; // å³æ™‚å¤‰åŒ–ãƒ‘ã‚±ãƒƒãƒˆã®é‡è¤‡é€ä»˜å›æ•°
const int SAMPLE_SEND_DUP_CNT = 2; // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ‘ã‚±ãƒƒãƒˆã®é‡è¤‡é€ä»˜å›æ•°
const int SAMPLE_INTERVAL_MS = 3;  // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã®å‘¨æœŸ(msec)
const int SAMPLE_SEND_AMNT = 8;    // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ‘ã‚±ãƒƒãƒˆã®é€ä»˜ã‚µã‚¤ã‚º(å¤‰æ›´æ™‚ã¯é€ä»˜ãƒ‘ã‚±ãƒƒãƒˆã®ä¿®æ­£ãŒå¿…è¦)
const int SAMPLE_SUPPRESS_MS = 3; // å³æ™‚é€ä¿¡å¾Œã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚’æŠ‘åˆ¶ã™ã‚‹æ™‚é–“
// ==== å‰²ã‚Šè¾¼ã¿å‡¦ç† ====
const unsigned long DEBOUNCE_US = 3000;
volatile unsigned long lastKeyChangeMicros = 0;

// ==== é…å»¶åˆ†é¡ ====
// pingè¿”é€æ™‚é–“(msec)
const int RTT_THRESH_1 = 5;
const int RTT_THRESH_2 = 10;
const int RTT_THRESH_3 = 25;
const int RTT_THRESH_4 = 50;
const int RTT_THRESH_5 = 75;
const int RTT_THRESH_6 = 100;
const int RTT_THRESH_7 = 200;

// pingè¿”é€æ™‚é–“é–“éš”ã”ã¨ã®é…å»¶æ™‚é–“å®šç¾©(msec)
const int DELAY_VERY_LOW = 50;    // RTT_THRESH_1ä»¥ä¸‹
const int DELAY_LOW = 60;         // RTT_THRESH_2ä»¥ä¸‹
const int DELAY_MID = 75;         // RTT_THRESH_3ä»¥ä¸‹
const int DELAY_HIGH = 100;       // RTT_THRESH_4ä»¥ä¸‹
const int DELAY_VERY_HIGH = 125;  // RTT_THRESH_5ä»¥ä¸‹
const int DELAY_VERY2_HIGH = 150; // RTT_THRESH_6ä»¥ä¸‹
const int DELAY_VERY3_HIGH = 250; // RTT_THRESH_7ä»¥ä¸‹
const int DELAY_MAX = 500;        // RTT_THRESH_7è¶…

const unsigned long BLINK_INTERVAL_WIFI = 1000;
const unsigned long BLINK_INTERVAL_SYNC = 300;
unsigned long blinkInterval = BLINK_INTERVAL_WIFI;
unsigned long lastSyncRequestMillis = 0;

// ==== çŠ¶æ…‹ç®¡ç† ====
volatile bool immediateSendRequested = false;
volatile bool keyState = false;
volatile unsigned long lastIsrMicros = 0;

//unsigned long lastSendMicros = 0;
unsigned long lastOnMillis = 0;
unsigned long lastBlinkMillis = 0;
unsigned long lastPingMillis = 0;
unsigned long lastPingSendMillis = 0;
long delayOffsetMs = 0;
bool timeSynced = false;
bool ledState = false;
unsigned long dynamicTimeout = 8000;
static unsigned long lastDelayRecalcMillis = 0;
int fixedDelayMs = 50;
bool fixedDelayLocked = false;
bool wifiWasDisconnected = false;
bool currentKeyState = false;

int lostPingCount = 0;
bool pongReceived = true; // pongå¿œç­”ãŒæ¥ãŸã‹ã©ã†ã‹

const unsigned long DEFAULT_TIMEOUT_MIN = 4000;
const unsigned long DEFAULT_TIMEOUT_MAX = 12000;
int activeProfileIndex = -1;
unsigned long profileSelectStart = 0;
const unsigned long PROFILE_SELECT_WINDOW = 10000; // 10ç§’
int selectedProfileIndex = 0;
unsigned long fixedDelayLockUntil = 0;

// ==== ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ç”¨å¤‰æ•° ====
static byte keyBuf = 0;
static int sampleIndex = 0;
static unsigned long sampleStartTimeMs = 0;
static unsigned long lastSampleTimeMs = 0;
const int PACKET_SEND_INTERVAL_MS = SAMPLE_INTERVAL_MS * SAMPLE_SEND_AMNT;
unsigned long lastImmediateSendMillis = 0;
unsigned long sampleTimes[8];

// ==== é–¢æ•°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ— ====
bool connectToWiFi();
void requestMillisSync();
void sendKeyPacket(bool isOn, byte trxSel, uint64_t opTimeMs);
void setLedColor(uint8_t r, uint8_t g, uint8_t b);
void flashRedBeforeRestart();

// ==== RTTå±¥æ­´ ====
const int RTT_HISTORY_SIZE = 5;
long rttHistory[RTT_HISTORY_SIZE] = {0};
int rttIndex = 0;
long pingRttMs = 0;

long getAverageRtt()
{
  long sum = 0;
  for (int i = 0; i < RTT_HISTORY_SIZE; i++)
    sum += rttHistory[i];
  return sum / RTT_HISTORY_SIZE;
}

void keyISR()
{
  if (!timeSynced)
    return;
  unsigned long now = micros();
  if (now - lastIsrMicros < DEBOUNCE_US)
    return;
  lastIsrMicros = now;
  keyState = (digitalRead(KEY_PIN) == LOW);
  lastKeyChangeMicros = now; // â† è¿½åŠ 
  immediateSendRequested = true;
}
// ==== åˆæœŸåŒ– ====
void setup()
{
  Serial.begin(115200);

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(KEY_PIN, INPUT_PULLUP);
  pixels.begin();
  pixels.setBrightness(50); // æ˜ã‚‹ã•èª¿æ•´ï¼ˆ0ã€œ255ï¼‰

  ColorProfile *c = wifiProfiles[selectedProfileIndex].color;
  setLedColor(c->r, c->g, c->b);

  profileSelectStart = millis();

  // 10ç§’é–“ã ã‘é¸æŠå¯èƒ½

  while (millis() - profileSelectStart < PROFILE_SELECT_WINDOW)
  {
    static bool lastButtonState = HIGH;
    bool buttonState = digitalRead(BUTTON_PIN);
    if (lastButtonState == HIGH && buttonState == LOW)
    {
      selectedProfileIndex = (selectedProfileIndex + 1) % profileCount;
      c = wifiProfiles[selectedProfileIndex].color;
      setLedColor(c->r, c->g, c->b);
      // Serial.printf("ğŸ”„ ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«åˆ‡æ›¿: %d (%s)\n", selectedProfileIndex, wifiProfiles[selectedProfileIndex].ssid);
    }
    lastButtonState = buttonState;
    delay(100);
  }

  activeProfileIndex = selectedProfileIndex;

  c = wifiProfiles[activeProfileIndex].color;
  setLedColor(c->r, c->g, c->b);
  gpio_pad_select_gpio((gpio_num_t)BUTTON_PIN);
  gpio_set_direction((gpio_num_t)BUTTON_PIN, GPIO_MODE_DISABLE);
  attachInterrupt(digitalPinToInterrupt(KEY_PIN), keyISR, CHANGE);
  connectToWiFi();
  Udp.begin(LOCAL_PORT);
  requestMillisSync();
  lastPingMillis = millis();
}

// ==== LEDåˆ¶å¾¡ç”¨é–¢æ•° ====
void setLedColor(uint8_t r, uint8_t g, uint8_t b)
{
  pixels.setPixelColor(0, pixels.Color(r, g, b));
  pixels.show();
}

// ==== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ====
void loop()
{
  unsigned long nowMicros = micros();
  unsigned long nowMillis = millis();
  byte trxCode = 0x01; // å›ºå®šã™ã‚‹

  // ==== SYNCå†é€ã®å¼·åŒ–ï¼ˆåˆå›ï¼‹å‘¨æœŸï¼‰ ====

  static bool syncRequested = false;
  static unsigned long lastSyncRetryMillis = 0;

  if (!timeSynced && WiFi.status() == WL_CONNECTED)
  {
    if (!syncRequested || millis() - lastSyncRetryMillis >= 5000)
    {
      requestMillisSync();
      syncRequested = true;
      lastSyncRetryMillis = millis();
      // Serial.println("SYNCè¦æ±‚ã‚’é€ä¿¡ã—ã¾ã—ãŸ");
    }
  }

  // å³æ™‚é€ä¿¡å‡¦ç†
  bool doSend = false;
  bool sendState = false;
  noInterrupts();
  if (immediateSendRequested)
  {
    doSend = true;
    sendState = keyState;
    unsigned long isrMicros = lastKeyChangeMicros; // â† å‰²ã‚Šè¾¼ã¿æ™‚åˆ»ã‚’å–å¾—
    // delay(2);
    immediateSendRequested = false;
  }
  interrupts();

  if (doSend && timeSynced)
  {
    fixedDelayLocked = true; // â‘  é…å»¶æ™‚é–“ã®å†è©•ä¾¡ã‚’é˜²æ­¢

    currentKeyState = sendState;
    uint64_t opTimeMs = (lastKeyChangeMicros / 1000) + delayOffsetMs + fixedDelayMs;
    int repeat = currentKeyState ? 1 : 3; // OFFæ™‚ã¯3å›é€ä¿¡
    for (int i = 0; i < repeat; i++)
    {
      sendKeyPacket(currentKeyState, trxCode, opTimeMs); // opTimeMsã¯å›ºå®š
      yield();                                           // WiFiã‚¹ã‚¿ãƒƒã‚¯å®‰å®šåŒ–ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    }

    //lastSendMicros = nowMicros;
    lastOnMillis = currentKeyState ? nowMillis : lastOnMillis;
    lastImmediateSendMillis = millis();
  }

  // ==== SAMPLE_INTERVAL_MSã”ã¨ã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å‡¦ç† ====
  if (timeSynced && millis() - lastSampleTimeMs >= SAMPLE_INTERVAL_MS)
  {
    // å³æ™‚é€ä¿¡å¾Œã¯æŠ‘åˆ¶
    if (millis() - lastImmediateSendMillis < SAMPLE_SUPPRESS_MS)
      return;
    // å³æ™‚é€ä¿¡ä¸­ã¯ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é€ä¿¡ã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (immediateSendRequested)
      return;

    lastSampleTimeMs = millis();
    bool down = (digitalRead(KEY_PIN) == LOW);
    if (sampleIndex == 0)
    {
      sampleStartTimeMs = millis();
      keyBuf = 0; // â† åˆæœŸåŒ–ã‚’ã“ã“ã«ç§»å‹•
    }

    sampleTimes[sampleIndex] = millis(); // â† ã“ã“ã«è¿½åŠ ï¼

    if (down)
      keyBuf |= (1 << sampleIndex);
    sampleIndex++;

    if (sampleIndex >= SAMPLE_SEND_AMNT)
    {
      // byte trxCode = (digitalRead(TRX_PIN) == LOW) ? 0x02 : 0x01;
      trxCode = 0x01;
      byte pkt[13];
      pkt[0] = trxCode;
      pkt[1] = keyBuf;
      pkt[2] = (sampleStartTimeMs >> 16) & 0xFF;
      pkt[3] = (sampleStartTimeMs >> 8) & 0xFF;
      pkt[4] = sampleStartTimeMs & 0xFF;
      for (int i = 0; i < 8; i++)
      {
        byte delta = (byte)constrain(sampleTimes[i] - sampleStartTimeMs, 0, 255);
        pkt[5 + i] = delta;
      }

      for (int i = 0; i < SAMPLE_SEND_DUP_CNT; i++)
      {
        Udp.beginPacket(serverIP, SERVER_PORT);
        Udp.write(pkt, 13);
        Udp.endPacket();
        yield(); // WiFiå®‰å®šåŒ–
      }

      sampleIndex = 0;
    }
  }

  // UDPå—ä¿¡å‡¦ç†
  int size = Udp.parsePacket();
  if (size > 0)
  {
    byte buf[12];
    int len = Udp.read(buf, size);

    if (size == 9 && buf[0] == 0xE1)
    {
      uint64_t serverRecvMs = 0;
      for (int i = 0; i < 8; i++)
        serverRecvMs = (serverRecvMs << 8) | buf[1 + i];

      long offset = (long)serverRecvMs - (long)nowMillis;

      // === ã‚µãƒ¼ãƒãƒ¼å†èµ·å‹•æ¤œå‡º ===
      if (offset < 3000)
      {
        // ã‚µãƒ¼ãƒãƒ¼ ãŒ3ç§’ä»¥ä¸Šå…ˆã«å‹•ã„ã¦ã„ãªã„å ´åˆã¯å†èµ·å‹•
        Serial.println("ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•æ™‚é–“ãŒå¤§å¹…ã«å·»ãæˆ»ã‚Šã¾ã—ãŸã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’å†èµ·å‹•ã—ã¾ã™ã€‚");
        flashRedBeforeRestart();
        ESP.restart(); // â† ESP32ã‚’ã‚½ãƒ•ãƒˆãƒªã‚»ãƒƒãƒˆ
        return;
      }

      delayOffsetMs = offset;

      // ä»¥ä¸‹ã€é€šå¸¸ã®SYNCå‡¦ç†ï¼ˆåˆæœŸåŒ–ãªã©ï¼‰
      timeSynced = true;
      // RTTã«å¿œã˜ã¦åˆæœŸé…å»¶ã‚’è¨­å®šï¼ˆå›ºå®šåŒ–ï¼‰
      if (pingRttMs <= RTT_THRESH_1)
        fixedDelayMs = DELAY_VERY_LOW;
      else if (pingRttMs <= RTT_THRESH_2)
        fixedDelayMs = DELAY_LOW;
      else if (pingRttMs <= RTT_THRESH_3)
        fixedDelayMs = DELAY_MID;
      else if (pingRttMs <= RTT_THRESH_4)
        fixedDelayMs = DELAY_HIGH;
      else if (pingRttMs <= RTT_THRESH_5)
        fixedDelayMs = DELAY_VERY_HIGH;
      else if (pingRttMs <= RTT_THRESH_6)
        fixedDelayMs = DELAY_VERY2_HIGH;
      else if (pingRttMs <= RTT_THRESH_7)
        fixedDelayMs = DELAY_VERY3_HIGH;
      else
        fixedDelayMs = DELAY_MAX;

      fixedDelayLocked = true;                // é€šå¸¸ã¯ãƒ­ãƒƒã‚¯ã—ã¦å®‰å®šé‹ç”¨
      fixedDelayLockUntil = millis() + 30000; // 10ç§’é–“ãƒ­ãƒƒã‚¯ç¶­æŒ

      lastPingMillis = nowMillis;
      lastPingSendMillis = nowMillis;
      blinkInterval = BLINK_INTERVAL_SYNC;

      // fixedDelayLocked = false;
      rttIndex = 0;
      for (int i = 0; i < RTT_HISTORY_SIZE; i++)
        rttHistory[i] = 0;

      sampleIndex = 0;
      keyBuf = 0;
      lastSampleTimeMs = nowMillis;
      lastSyncRequestMillis = nowMillis;
      lastSyncRetryMillis = nowMillis;

      // ä¸€ç¬èµ¤ã§ç‚¹ç¯
      pixels.setPixelColor(0, pixels.Color(255, 0, 0)); // èµ¤
      pixels.show();
      delay(100);

      // currentKeyState ã«å¿œã˜ã¦è¡¨ç¤º
      if (currentKeyState)
      {
        pixels.setPixelColor(0, pixels.Color(0, 255, 0)); // ç·‘
      }
      else
      {
        pixels.clear(); // æ¶ˆç¯
      }
      pixels.show();
    }

    else if (size == 1 && buf[0] == 0xFE)
    {
      pongReceived = true;

      long rtt = nowMillis - lastPingSendMillis;
      rttHistory[rttIndex] = rtt;
      rttIndex = (rttIndex + 1) % RTT_HISTORY_SIZE;
      pingRttMs = getAverageRtt();

      if (!fixedDelayLocked && !currentKeyState && (millis() - lastOnMillis > 1000))
      {
        if (pingRttMs <= RTT_THRESH_1)
          fixedDelayMs = DELAY_VERY_LOW;
        else if (pingRttMs <= RTT_THRESH_2)
          fixedDelayMs = DELAY_LOW;
        else if (pingRttMs <= RTT_THRESH_3)
          fixedDelayMs = DELAY_MID;
        else if (pingRttMs <= RTT_THRESH_4)
          fixedDelayMs = DELAY_HIGH;
        else if (pingRttMs <= RTT_THRESH_5)
          fixedDelayMs = DELAY_VERY_HIGH;
        else if (pingRttMs <= RTT_THRESH_6)
          fixedDelayMs = DELAY_VERY2_HIGH;
        else if (pingRttMs <= RTT_THRESH_7)
          fixedDelayMs = DELAY_VERY3_HIGH;
        else
          fixedDelayMs = DELAY_MAX;

        fixedDelayLocked = true;
      }

      lastPingMillis = nowMillis;
    }
  }

  // PINGé€ä¿¡
  if (timeSynced && nowMillis - lastPingMillis > PING_INTERVAL)
  {
    if (!pongReceived)
    {
      if (!currentKeyState)
      { // ã‚­ãƒ¼é€ä¿¡ä¸­ã¯è¡¨ç¤ºã—ãªã„
        lostPingCount++;
        // Serial.printf("âš ï¸ Ping lost! Count: %d (last RTT=%ld ms)\n", lostPingCount, pingRttMs);
      }
      else
      {
        // ã‚­ãƒ¼é€ä¿¡ä¸­ã¯ã‚«ã‚¦ãƒ³ãƒˆã‚‚æ­¢ã‚ã‚‹
        lostPingCount = 0;
      }
    }
    pongReceived = false;

    byte ping = 0xFF;
    Udp.beginPacket(serverIP, SERVER_PORT);
    Udp.write(&ping, 1);
    Udp.endPacket();
    lastPingSendMillis = nowMillis;
  }

  // é…å»¶æ™‚é–“å†è¨ˆç®—
  if (timeSynced && nowMillis - lastDelayRecalcMillis >= ReCal_RTT)
  {
    lastDelayRecalcMillis = nowMillis;
    pingRttMs = getAverageRtt();

    if (!fixedDelayLocked)
    {
      if (pingRttMs <= RTT_THRESH_1)
        fixedDelayMs = DELAY_VERY_LOW;
      else if (pingRttMs <= RTT_THRESH_2)
        fixedDelayMs = DELAY_LOW;
      else if (pingRttMs <= RTT_THRESH_3)
        fixedDelayMs = DELAY_MID;
      else if (pingRttMs <= RTT_THRESH_4)
        fixedDelayMs = DELAY_HIGH;
      else if (pingRttMs <= RTT_THRESH_5)
        fixedDelayMs = DELAY_VERY_HIGH;
      else if (pingRttMs <= RTT_THRESH_6)
        fixedDelayMs = DELAY_VERY2_HIGH;
      else if (pingRttMs <= RTT_THRESH_7)
        fixedDelayMs = DELAY_VERY3_HIGH;
      else
        fixedDelayMs = DELAY_MAX;
    }
  }

  // ==== ã‚µãƒ¼ãƒå¿œç­”ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ¤œå‡º ====
  if (timeSynced && nowMillis - lastPingMillis >= dynamicTimeout)
  {
    timeSynced = false;
    blinkInterval = BLINK_INTERVAL_WIFI;
    fixedDelayLocked = false;
    // Serial.println("ã‚µãƒ¼ãƒã¨ã®æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€‚å¾…æ©ŸçŠ¶æ…‹ã«æˆ»ã‚Šã¾ã™ã€‚");
  }

  // 5ç§’ä»¥ä¸Šã‚­ãƒ¼æŠ¼ä¸‹ãŒãªã„å ´åˆã¯é…å»¶å†è©•ä¾¡ã‚’è¨±å¯
  if (timeSynced && !currentKeyState && (millis() - lastOnMillis >= 5000))
  {
    fixedDelayLocked = false;
  }

  // LEDç‚¹æ»…
  if (nowMillis - lastBlinkMillis >= blinkInterval)
  {
    ledState = !ledState;
    // digitalWrite(LED_PIN, ledState ? HIGH : LOW);
    if (ledState)
    {
      pixels.setPixelColor(0, pixels.Color(0, 255, 0)); // ç·‘
    }
    else
    {
      pixels.clear(); // æ¶ˆç¯
    }
    pixels.show();
    lastBlinkMillis = nowMillis;
  }

  // WiFiåˆ‡æ–­æ¤œå‡º
  if (WiFi.status() != WL_CONNECTED)
  {
    wifiWasDisconnected = true;
    timeSynced = false;
    blinkInterval = BLINK_INTERVAL_WIFI;
    fixedDelayLocked = false;
  }

  // ==== SYNCå†é€ã®è‡ªå‹•åŒ– ====
  if (!timeSynced && WiFi.status() == WL_CONNECTED && millis() - lastSyncRetryMillis >= 5000)
  {
    requestMillisSync();
    lastSyncRetryMillis = millis();
    // Serial.println("SYNCå†é€è¦æ±‚ã‚’é€ä¿¡ã—ã¾ã—ãŸ");
  }

  if (!timeSynced)
    return;

  // ONå®‰å…¨å¯¾ç­–
  if (currentKeyState && nowMillis - lastOnMillis > MAX_ON_DURATION)
  {
    currentKeyState = false;
    uint64_t opTimeMs = nowMillis + delayOffsetMs + fixedDelayMs;
    sendKeyPacket(false, trxCode, opTimeMs);
  }

  if (fixedDelayLocked && millis() > fixedDelayLockUntil)
  {
    fixedDelayLocked = false;
  }
}

// ==== WiFiæ¥ç¶š ====
bool connectToWiFi()
{

  WiFiProfile profile = wifiProfiles[activeProfileIndex]; // â† é¸æŠæ¸ˆã¿ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã ã‘ä½¿ã†ï¼
  WiFi.config(profile.localIP, profile.gateway, profile.subnet);
  WiFi.begin(profile.ssid, profile.password);

  for (int t = 0; t < 60; t++)
  {
    if (WiFi.status() == WL_CONNECTED)
    {
      serverIP = profile.serverIP;
      int rssi = WiFi.RSSI();
      dynamicTimeout = constrain(map(rssi, -90, -30, DEFAULT_TIMEOUT_MAX, DEFAULT_TIMEOUT_MIN),
                                 DEFAULT_TIMEOUT_MIN, DEFAULT_TIMEOUT_MAX);
      // Serial.printf("âœ… æ¥ç¶šæˆåŠŸ: SSID=%s, IP=%s\n", profile.ssid, WiFi.localIP().toString().c_str());
      // Serial.printf("âœ… æ¥ç¶šæˆåŠŸ: SSID=%s", profile.ssid);
      return true;
    }
    if (WiFi.status() == WL_NO_SSID_AVAIL)
    {
      // Serial.println("â³ SSIDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å†è©¦è¡Œä¸­...");
    }
    delay(500);
  }

  // Serial.printf("âŒ æ¥ç¶šå¤±æ•—: SSID=%s\n", profile.ssid);
  return false;
}

// ==== SYNCè¦æ±‚ï¼ˆæ™‚åˆ»è£œæ­£å°‚ç”¨ï¼‰ ====
void requestMillisSync()
{
  lastSyncRequestMillis = millis();
  lastPingSendMillis = lastSyncRequestMillis;
  byte pkt[5] = {
      0xE0,
      (byte)((lastSyncRequestMillis >> 24) & 0xFF),
      (byte)((lastSyncRequestMillis >> 16) & 0xFF),
      (byte)((lastSyncRequestMillis >> 8) & 0xFF),
      (byte)(lastSyncRequestMillis & 0xFF)};
  Udp.beginPacket(serverIP, SERVER_PORT);
  Udp.write(pkt, 5);
  Udp.endPacket();
}

// ==== ã‚­ãƒ¼ãƒ‘ã‚±ãƒƒãƒˆé€ä¿¡ ====
void sendKeyPacket(bool isOn, byte trxSel, uint64_t opTimeMs)
{
  byte pkt[10];
  pkt[0] = isOn ? 0x01 : 0x00;
  pkt[1] = trxSel;
  for (int i = 0; i < 8; i++)
    pkt[2 + i] = (opTimeMs >> (56 - i * 8)) & 0xFF;

  for (int i = 0; i < keyRepeatCount; i++)
  {
    if (!Udp.beginPacket(serverIP, SERVER_PORT))
      return;
    Udp.write(pkt, 10);
    Udp.endPacket();
    yield();
  }

  if (isOn)
  {
    pixels.setPixelColor(0, pixels.Color(255, 0, 0)); // èµ¤
  }
  else
  {
    pixels.clear();
  }
  pixels.show();
}

void flashRedBeforeRestart()
{
  for (int i = 0; i < 3; i++)
  {
    pixels.setPixelColor(0, pixels.Color(255, 0, 0)); // èµ¤
    pixels.show();
    delay(100);
    pixels.clear();
    pixels.show();
    delay(100);
  }
}